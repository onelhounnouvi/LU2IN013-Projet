\documentclass[a4paper]{article}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{enumitem}
\usepackage[colorlinks = true, linkcolor = blue]{hyperref}
\usepackage{amsmath}
\usepackage{float}

\usepackage{xcolor}

\newcommand{\highlight}[1]{\textbf{\textcolor{red}{\underline{#1}}}}



\title{
    \includegraphics[width=5cm]{logo_su.jpg} \\[1em]
    \Huge Automatisation de la cryptanalyse des cryptosystèmes classiques à l’aide d’algorithmes modernes
}

\author{Helder Brito\\O'nel Hounnouvi}
\date{}

\begin{document}

\maketitle 
\clearpage 
\tableofcontents
\clearpage 

\section{Substitution monoalphabétique}

\subsection{Introduction}

La substitution monoalphabétique est l'une des plus anciennes méthodes de chiffrement. Elle consiste à remplacer dans le message clair une lettre donnée de l'alphabet par une autre lettre. Voici un exemple:

\vspace{1em}
\begin{adjustbox}{width=\textwidth,center}
    \begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|}
        \hline
        A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q & R & S & T & U & V & W & X & Y & Z \\
        \hline
        X & Y & Z & A & B & C & D & E & F & G & H & I & J & K & L & M & N & O & P & Q & R & S & T & U & V & W \\
        \hline
    \end{tabular}
\end{adjustbox}
\vspace{1em}

Le message \textit{SUBSTITUTION} devient \textit{PRYPQFQRQFLK}.\\

L'alphabet latin comporte 26 lettres. Cela permet donc de construire $26! = 4 \times 10^{26}$ permutations, soit de l'ordre de $2^{88}$.  
Sachant qu’environ $2^{58}$ secondes se sont écoulées depuis la création de l’univers, il serait impossible d’explorer toutes les permutations.  
Ce chiffre donne une impression de sûreté qui est toutefois trompeuse\ldots

\subsection{Cryptanalyse}

\subsubsection{Un peu de vocabulaire}

Le \textbf{déchiffrage} est consiste à convertir un message chiffré en son contenu original (le texte clair) lorsqu'on est en possession de la clé.
La \textbf{cryptanalyse} quant à elle est l'ensemble des techniques mises en œuvre pour tenter de casser le message codé sans avoir la clé de chiffrement.
Un \textbf{n-gramme} est une séquence de $n$ lettres consécutives dans un texte.
Par exemple, dans le mot \textit{CRYPTANALYSE}, les bigrammes ($n=2$) incluent \textit{CR}, \textit{RY}, \textit{YP}, \ldots, tandis que les trigrammes ($n=3$) sont \textit{CRY}, \textit{RYP}, \textit{YPT}, \ldots.  


\subsubsection{Attaque}

La substitution monoalphabétique possède une grosse faiblesse structurelle. Chaque occurrence d’une lettre du texte clair est systématiquement remplacée par la même lettre chiffrée. Ainsi, les caractéristiques statistiques de la langage française sont conservés en partie dans le message chiffré.  
C'est cette faille que nous allons exploiter.
Notre analyse ici sera basée sur l’analyse des fréquences d’apparition des n-grammes dans le message chiffré.

En utilisant un dictionnaire de référence contenant les fréquences relatives des n-grammes dans un large corpus de textes en français, il est possible d’estimer la probabilité qu’un texte donné soit écrit dans cette langue.

\subsubsection{Fitness function}

Pour évaluer la qualité des solutions potentielles et identifier celle qui convient le mieux, nous attribuons un score à chaque solution avec une \textit{fitness function}.
Pour être efficace, une telle fonction doit être suffisamment discriminante c'est à dire ressortir les différences entre un texte encore très chiffré (score mauvais) et un texte proche du clair (score bon). Elle doit être aussi rapide à calculer, car elle sera appelée de nombreuses fois.   
La fitness function utilisée dans ce projet est basée sur la somme des probabilités logarithmiques des n-grammes du texte chiffré. C’est la fonction de log-vraisemblance. Elle est définie comme suit:

\[
score = - \sum \log(frequence(c_1 \ldots c_n))
\]

L’objectif ici est de minimiser ce score. La solution ayant le plus petit score est celle qui sera «le plus» français.

\subsection{Métaheuristiques}

Une métaheuristique est un algorithme d’optimisation itératif et stochastique\footnote{Un processus stochastique est un processus dont l’évolution est déterminée par des phénomènes aléatoires.} destiné à résoudre des problèmes pour lesquels aucune méthode classique plus efficace n'existe. Ici elle servira à nous rapprocher le plus possible du minimum glabal de la fonction score.

\subsubsection{Hill Climbing}

L’idée générale est la suivante:
\begin{enumerate}
    \item \textbf{Initialisation:}
    \begin{enumerate}
        \item Partir d'une clé aléatoire $C1$ et l'utiliser pour déchiffrer le cryptogramme
        \item Calculer le score du texte obtenu
    \end{enumerate}
    \item \textbf{Boucle principale:}
    \begin{enumerate}[label= (\alph*)]
        \item \label{item:modification} Générer une solution voisine $C2$ en faisant une légère modification et calculer le nouveau score
        \item Si ce score est meilleur que le score précédent, adopter cette nouvelle clef comme clef courante: $C1 \leftarrow C2$\\
              Sinon, conserver l’ancienne clé $C1$.
    \end{enumerate}
    \item \textbf{Critère d'arrêt:} Terminer l'algorithme après un nombre prédéfini d'itérations, ou lorsqu'on a atteint un nombre prédéfini d'itérations sans amélioration du score (stagnation).
\end{enumerate}

Il arrive fréquemment que l’algorithme se retrouve bloqué dans un minimum local: il n’arrive plus à améliorer la solution actuelle, bien que meilleure solution globale n’ait pas encore été trouvée.  
C'est pour éviter qu'il reste longtemps dans cette impasse que nous introduisons une condition d'arrêt basée sur la variable max-stagnation.

\subsubsection*{Modification de la clef}\label{sec:modification_de_la_clef}

Il nous faut maintenant définir comment générer une clé voisine à la clé courante (étape 2-\ref{item:modification} de l’algorithme).  
Pour cela, on effectue une permutation aléatoire de deux lettres dans la clef. En guise d'exemple:

\begin{center}
\texttt{Q\highlight{W}ERTZUIOPASDF\highlight{G}HJKLXCVBNM} $\rightarrow$ \texttt{Q\highlight{G}ERTZUIOPASDF\highlight{W}HJKLXCVBNM}
\end{center}


\subsubsection{Hill Climbing optimisé}

Comme son nom l’indique, cette méthode est une version améliorée du Hill Climbing classique. Elle apporte une solution au blocage dans un minimum local.
Au lieu d’abandonner après une stagnation excessive, elle effectue une réinitialisation de la recherche. Une nouvelle clef aléatoire est générée, et l’algorithme recommence depuis l’étape 1.
Cette stratégie permet d’explorer plusieurs régions de l’espace des solutions, augmentant ainsi significativement les chances d’atteindre le minimum global — autrement dit, la solution correcte.

Notons qu'on enregistre la meilleure solution trouvée jusqu'à présent, afin de ne pas perdre les progrès réalisés.

\subsubsection{Recuit simulé}
Le recuit simulé est une méthode d’optimisation inspirée du processus de recuit en métallurgie, où un matériau est chauffé puis refroidi lentement pour atteindre un état de faible énergie.
Notre algorithme est présenté de la façon suivante:
\begin{enumerate}
    \item \textbf{Initialisation:} 
    \begin{enumerate}
        \item Partir d'une clé aléatoire $C1$ et d'une température initiale $T_0$
        \item Utiliser la clé pour dechiffrer le cryptogramme
        \item Calculer le score du texte obtenu
    \end{enumerate}
    \item \textbf{Boucle principale:}
    \begin{enumerate}[label= (\alph*)]
        \item Générer une solution voisine $C2$ en faisant une légère modification (voir~\ref{sec:modification_de_la_clef})
        \item Calculer le changement de coût, défini par
        \[
            \Delta = score(C2) - score(C1).
        \]
        \item Si $\Delta \leq 0$, accepter $C2$ (la solution s'améliore ou reste équivalente)
        \item Sinon, accepter $C2$ avec une probabilité donnée par
        \[
            P_{\text{accept}} = \exp\left(-\frac{\Delta}{T}\right).
        \]
        \item Mettre à jour la température avec le coefficient de refroidissement $\alpha$ après un nombre d'itérations:
        \[
            T \leftarrow \alpha T, \quad \text{avec } 0 < \alpha < 1.
        \]
    \end{enumerate}
    
    \item \textbf{Critère d'arrêt:} Terminer l'algorithme après un nombre prédéfini d'itérations, puis retourner la solution finale $s$.
\end{enumerate}


Le recuit simulé échappe aux minima locaux en introduisant une étape d'acceptation probabiliste des solutions moins bonnes. Concrètement, au lieu d'accepter uniquement les modifications qui améliorent le score, l'algorithme accepte une solution voisine avec la probabilité $P_{\text{accept}}$.
Au début, la température T est élevée, ce qui rend l'expression $\exp\left(-\frac{\Delta}{T}\right)$ relativement grande. Cela permet donc à l'algorithme d'accepter des solutions moins bonnes et d'explorer plus librement l'espace de recherche, en sautant potentiellement hors d'un minimum local.

Au fur et à mesure que l'algorithme progresse, la température est progressivement abaissée (refroidissement), ce qui diminue la probabilité d'accepter des solutions moins performantes. Ainsi, en phase finale, le recuit simulé affine la solution dans un voisinage qui se rapproche d'un minimum global.

\subsubsection{Recherche tabou}

La recherche tabou utilise une mémoire pour éviter de revisiter des solutions déjà explorées. L'idée générale est la suivante:

\begin{enumerate}
    \item \textbf{Initialisation:}
    \begin{enumerate}
        \item Partir d'une clé aléatoire $C1$ et l'utiliser pour déchiffrer le cryptogramme.
        \item Calculer le score du texte obtenu.
        \item Initialiser une liste tabou vide, qui servira à mémoriser les solutions récemment explorées.
    \end{enumerate}
    \item \textbf{Boucle principale:}
    \begin{enumerate}[label= (\alph*)]
        \item Explorer un echantillon de clés voisines $C2$ en faisant de légères modifications (voir~\ref{sec:modification_de_la_clef}).
        \item Vérifier si $C2$ est dans la liste tabou. Si oui, rejeter la solution
        \item Sinon, calculer le score de $C2$. Si ce score est meilleur que le score précédent, adopter cette nouvelle clé comme clé courante : $C1 \leftarrow C2$.
        \item Ajouter $C2$ à la liste tabou et, si nécessaire, retirer les éléments les plus anciens pour maintenir la taille maximale de la liste.
    \end{enumerate}
    \item \textbf{Critère d'arrêt:} Terminer l'algorithme après un nombre prédéfini d'itérations.
\end{enumerate}


En interdisant temporairement certaines solutions, la recherche tabou favorise l'exploration de nouvelles régions de l'espace de recherche et donc d'échapper aux minima locaux.

\section{Résultats expérimentaux}

Pour évaluer l’efficacité des différentes méthodes métaheuristiques, nous avons réalisé trois jeux de tests pour chaque algorithme. Dans chacun de ces tests, nous avons utilisé des textes chiffrés de longueurs différentes: 110, 509 et 1150 caractères.

L'objectif était d'observer l’évolution du score en fonction des différents paramètres clés. Cela permet d’analyser la rapidité de convergence, la stabilité, ainsi que la capacité de chaque méthode à s’approcher du minimum global.

Les résultats obtenus sont présentés sous forme de graphiques pour une comparaison visuelle claire entre les méthodes.

\subsection{Hill Climbing}

Pour évaluer l’efficacité des différentes méthodes métaheuristiques, nous avons réalisé trois jeux de tests pour chaque algorithme avec des textes chiffrés de 100, 500 et 1150 caractères.

Les résultats obtenus sont présentés en \hyperref[sec:annexes]{annexe}, notamment:
\begin{itemize}
    \item \hyperref[fig:hill_110]{Figure~\ref*{fig:hill_110}}: Hill Climbing sur un texte de 110 caractères,
    \item \hyperref[fig:hill_509]{Figure~\ref*{fig:hill_509}}: Hill Climbing sur un texte de 509 caractères,
    \item \hyperref[fig:hill_1150]{Figure~\ref*{fig:hill_1150}}: Hill Climbing sur un texte de 1150 caractères.
\end{itemize}

\textbf{Impact de la longueur du texte}: Plus le texte est long, plus les scores tendent à baisser en moyenne, notamment pour les n-grammes de taille $3$ et $4$. Cela s'explique par le fait qu’un texte plus long fournit plus de contexte statistique, facilitant ainsi la détection de motifs valides en français.

\textbf{Limites du hill climbing}: L’algorithme ne parvient pas toujours à améliorer le score significativement, même en augmentant le nombre de permutations. Cela illustre bien la faiblesse principale de la méthode: son incapacité à sortir facilement d’un minimum local, surtout pour des critères exigeants (comme les quadrigrammes).
t efficace 
\textbf{Remarque}: Il est important ici de noter que le nombre de permutations effectuées n'équivaut pas forcément au nombre de permutations maximales autorisées. En effet, on peut très bien imaginer un cas où il reste 2000 permutations disponibles mais notre algorithme s'arrête car on a stagné durant 200 itérations.
durant 200 itérations


\subsection{Hill Climbing optimisé}

Lorsque l’on applique la version optimisée du hill climbing, on observe une amélioration notable de la qualité des résultats, notamment pour les trigrammes ($n=3$) et quadrigrammes ($n=4$). Grâce au mécanisme de relance (génération d’une nouvelle clef aléatoire après 200 itérations sans amélioration), l’algorithme parvient à explorer davantage l’espace des solutions.

\textbf{Observations principales}:
\begin{itemize}
    \item \textbf{Amélioration des scores moyens} : Pour un même nombre de permutations, les scores finaux sont généralement supérieurs à ceux obtenus par le hill climbing standard, en particulier pour les grands $n$-grammes.
    
    \item \textbf{Stabilité accrue} : Les résultats sont plus réguliers, avec une variance réduite par rapport au hill climbing simple. (Voir figure~\ref{fig:hillopt_509}) Cela signifie que l’algorithme est plus fiable, et ne dépend pas autant du hasard de la clef initiale.
    
    \item \textbf{Gain d’efficacité sur les grands textes} : Le bénéfice de la relance devient particulièrement visible avec les textes plus longs. (Voir figure~\ref{fig:hillopt_1150}) La diversité des séquences statistiques donne plus de chances à une clef correcte d’être distinguée par le score.
\end{itemize}

\textbf{Remarque} : Ces observations ne semblent pas tout à fait correspondre dans le cas où les textes sont courts : il n'y à presque aucun changement avec le hill climbing classique.

\subsection{Recuit simulé}

\clearpage
\appendix
\section*{Annexes}
\addcontentsline{toc}{section}{Annexes}
\label{sec:annexes}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{HillClimbing1.png}
    \caption{Hill Climbing sur un texte de 110 caractères.}
    \label{fig:hill_110}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{HillClimbing2.png}
    \caption{Hill Climbing sur un texte de 509 caractères.}
    \label{fig:hill_509}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{HillClimbing3.png}
    \caption{Hill Climbing sur un texte de 1150 caractères.}
    \label{fig:hill_1150}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{HillClimbingOptimiser1.png}
    \caption{Hill Climbing optimisé sur un texte de 110 caractères.}
    \label{fig:hillopt_110}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{HillClimbingOptimiser2.png}
    \caption{Hill Climbing optimisé sur un texte de 509 caractères.}\label{fig:hillopt_509}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{HillClimbingOptimiser3.png}
    \caption{Hill Climbing optimisé sur un texte de 1150 caractères.}
    \label{fig:hillopt_1150}
\end{figure}

\clearpage
\section*{Bibliographie}
\addcontentsline{toc}{section}{Bibliographie}
\label{sec:bibliographie}

Voici quelques sources utiles :
\begin{itemize}
    \item \url{https://www.bibmath.net/crypto/}
    \item \url{https://www.apprendre-en-ligne.net/crypto/index.php}.
    \item \url{https://www.universite.fr/ressource.pdf}.
\end{itemize}

\end{document}